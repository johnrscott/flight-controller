= Brushless DC Motor Control using STM32F746

This experiment is intended to establish whether PWM from general-purpose timers can control multiple BLDC motors. The results should decide whether it is feasible to perform all the motor control logic in a single MCU such as the STM32H747, which only has 2 advanced motor control timers, but has 10 general purpose timers. The advantages of using a single MCU is board simplicity, lower cost, and lower programming and flashing complexity. The disadvantage is any specific deficiencies with using general timers for three-phase PWM, and CPU conflict/contention running multiple motors on one CPU (this seems unlikely given how "slow" the motor control is, but it is worth checking).

== Method

The intention is create simple breadboard-based hardware to drive the T-Motor P1604 3800KV motor. The electrical design of the motor driver can be optimised later; the main intention of this experiment is to test the feasibility of the software.

The reference for the theory of BLDC motor control is xref:../../reference/appnote-brushless-dc-motor-control.pdf[this Microchip application note], which contains simple explanations of the basic commutation sequence in Figure 1, and describes open-loop control.

=== Hardware setup

Using the https://www.st.com/en/evaluation-tools/32f746gdiscovery.html[STM32F746-DISCO] board (because I have that lying around) and using xref:../../reference/datasheet-l298.pdf[L298N] dual full-bridge drivers (because I have these in stock).

The following is the list of components required for the hardware setup:

* 1 x T-Motor P1604 3800KV motor (mounted in AOS 3.5 V5 Freestyle Quadcopter Frame for this experiment)
* 1 x STM32F746 DISCO board
* 1 x breadboard
* 2 x L298N dual full-bridge drivers
* 4 x 100nF capacitors
* 6 x LEDs
* 6 x 100k resistors

The breadboard layout for the experiment is shown below 

.Breadboard layout for the experiment
image::breadboard.jpg[]

The design uses one half bridge out of three of the full bridges present across the two L298N chips. Each one of these half bridges drives one phase of the BLDC motor.

Each half bridge driving a phase must be able to drive the phase high, drive it low, and set it floating. To drive it high or low, the corresponding full bridge `ENA`/`ENB` signal must be asserted, and the input `IN1`/`IN3` must be set to high or low.

To set the half bridge to floating, de-assert the `ENA`/`ENB` signal (`IN1`/`IN3` is don't-care).

It is not possible to use the two half bridges from one full bridge independently because `ENA` covers the whole full bridge, but separate control of the half bridges is required.

NOTE: This type of scheme requires six signals: three floating/not-floating inputs, and three high/low inputs (applicable only when non-floating). The alternative scheme is to drive each MOSFET of the three half bridges separately, which still requires six signals. In summary, driving a BLDC requires 6 digital output pins.

The breadboard layout follows the schematic diagram in the datasheet for the L298N. On the input side, an LED is connected to each `EN`/`IN` pin, which is useful to see the commutation signals easily.

The logic signals are powered from the DISCO board at 3V3. The phase power supplies comes from a bench power supply (set to 12V, with a current limit at 2A).

WARNING: The full bridge drivers can only supply a current of 4A, hence the 2A current limit.

This setup does not use sensorless feedback, which involves reading the voltage on the floating signal. The objective here is just feasibility of driving the motors using timer PWM outputs, in open-loop mode.

PWM signals are only needed for the `IN` signals. The `EN` signals can be regular GPIOs because each phase only needs to be floating or not floating during a commutation step.

NOTE: When using the alternative scheme of driving each MOSFET in the three half bridges separately, you still only need three PWM signals, attached to the high-side MOSFETs. This is because the low-side MOSFETs are only used to decide which phases are floating, and which are sinking (and it is not necessary to apply PWM to both the line input and neutral output phases). 

=== Software setup

We will use this opportunity to try using Rust for something non-trivial with the STM32F7 series.

==== Getting basic PWM working

Although it is not clearly stated on the summary page of the STM32F746 datasheet, this MCU does have advanced control timers (TIM1 and TIM8). These timers have four channels, each of which has a positive and a complement pin (used for the high and low side of a half-H bridge). Three of these channels are suitable to drive a three-phase brushless motor.

A very quick test using the minimal project `pwm`, based on https://github.com/stm32-rs/stm32f7xx-hal/blob/main/examples/pwm.rs[this example], works on the STM32F746 DISCO board. The relevant lines to configure the PWM in Rust are:

[,rust]
----
// PA8 is pin 3 on CN7 on the Arduino header of the board. It
// corresponds to TIM1_CH1 (the into_alternate followed by passing
// it to the TIM1.pwm_hz() call configures the pin).
//
// PA9 is not mapped to any easily accessible pin on the DISCO board,
// but you can touch an oscilloscope probe on the SB13 bridge to see
// the signal
let gpioa = dp.GPIOA.split();
let channels = (gpioa.pa8.into_alternate(), gpioa.pa9.into_alternate());

let pwm = dp.TIM1.pwm_hz(channels, 20.kHz(), &clocks).split();
let (mut ch1, mut ch2) = pwm;

let max_duty = ch1.get_max_duty();
ch1.set_duty(max_duty / 2);
ch1.enable();

let max_duty = ch2.get_max_duty();
ch2.set_duty(max_duty / 4);
ch2.enable();
----

An immediate problem is the lack of conveniently-mapped pins on the DISCO board.

From the datasheet, the only timer channels with an easily accessible list of possible alternate pins for the 6 channels of TIM1, along with the pin use on the DISCO board, are:

* TIM1_CH1: PE9 (SDRAM use, data), PA8 (accessible pin header)
* TIM1_CH1N: PE8 (SDRAM use, data), PA7 (ETH use), PB13 (USB HS use)

* TIM1_CH2: PE11 (SDRAM use, data), PA9 (VCP_TX, part of ST-LINK circuit, SB13 jumper)
* TIM1_CH2N: TODO

* TIM1_CH3: PE13 (SDRAM use, data), PA10 (ID pin 4 of OTG FS, CN13)
* TIM1_CH3N: TODO

* TIM1_CH4: PE14 (SDRAM use, data), PA11 (DM pin 2 of OTG FS, CN13)
* TIM1_CH4N: TODO

From the data above, it is clear that TIM1 cannot be utilised without (probably) modifying the board (e.g. removing the SDRAM module). The same is true for TIM8, which is equally inaccessible. Testing the advanced timers is therefore out of scope for this first experiment.

The timer channels which are accessible on the headers are as follows:

* TIM12_CH1: PH6, pin7 CN4
* TIM12_CH2: PB15, pin 4 CN7
* TIM1_CH1: PA8, pin 3 CN7
* TIM2_CH1: PA15, pin 2 CN7
* TIM3_CH1: PB4, pin 4 CN4
* TIM5_CH4: PI0 (letter i, number zero), pin 6 CN4

Luckily, there are six timers here (these exhaust all the timers on the Arduino pin headers), so there is a possibility of three-phase motor control if the peripherals can be synchronised appropriately.

A snippet of the basic code required to turn on the channels is shown below:

[,rust]
----
// How to turn on one channel on a timer
// CN4, pin 4
let channels = gpiob.pb4.into_alternate();
let mut ch = dp.TIM3.pwm_hz(channels, 20.kHz(), &clocks).split();
let max_duty = ch.get_max_duty();
ch.set_duty(max_duty / 2);
ch.enable();

// How to turn on multiple channels in a timer
let channels = (gpioh.ph6.into_alternate(), gpiob.pb15.into_alternate());
let pwm = dp.TIM12.pwm_hz(channels, 20.kHz(), &clocks).split();
let (mut ch1 , mut ch2) = pwm;

// CN4, pin 7	
let max_duty = ch1.get_max_duty();
ch1.set_duty(max_duty / 4);
ch1.enable();	

// CN7, pin 4	
let max_duty = ch2.get_max_duty();
ch2.set_duty(max_duty / 7);
ch2.enable();
----

To set up the required three PWM signals and three GPIO signals, the following code snippet can be used:

[,rust]
----
// CN4, pin 4 -- enable_1
let mut enable_1 = gpiob.pb4.into_push_pull_output();
enable_1.set_high();

// CN4, pin 7 -- enable_2
let mut enable_2 = gpioh.ph6.into_push_pull_output();
enable_2.set_high();

// CN7, pin 1 -- enable_3
let mut enable_3 = gpioi.pi2.into_push_pull_output();
enable_3.set_low();

// CN4, pin 6 -- high_side_1
let channels = gpioi.pi0.into_alternate();
let mut high_side_1 = dp.TIM5.pwm_hz(channels, 20.kHz(), &clocks).split();
high_side_1.set_duty(1);
high_side_1.enable();

// CN7, pin 2 -- high_side_2
let channels = gpioa.pa15.into_alternate();
let mut high_side_2 = dp.TIM2.pwm_hz(channels, 20.kHz(), &clocks).split();
high_side_2.set_duty(1);
high_side_2.enable();

// CN7, pin 3 -- high_side_3
let channels = gpioa.pa8.into_alternate();
let mut high_side_3 = dp.TIM1.pwm_hz(channels, 20.kHz(), &clocks).split();
high_side_3.set_duty(1);
high_side_3.enable();
----

The commutation steps are performed as follows:

[,rust]
----
loop {

    // In line 1, out line 2
    enable_1.set_high();
    enable_2.set_high();
    enable_3.set_low();
    high_side_1.set_duty(duty_1);
    high_side_2.set_duty(0);
    high_side_3.set_duty(0);

    delay.delay_ms(comm_delay);

    // In line 3, out line 2
    enable_1.set_low();
    enable_2.set_high();
    enable_3.set_high();
    high_side_1.set_duty(0);
    high_side_2.set_duty(0);
    high_side_3.set_duty(duty_3);

    delay.delay_ms(comm_delay);

    // In line 3, out line 1
    enable_1.set_high();
    enable_2.set_low();
    enable_3.set_high();
    high_side_1.set_duty(0);
    high_side_2.set_duty(0);
    high_side_3.set_duty(duty_3);

    delay.delay_ms(comm_delay);

    // In line 2, out line 1
    enable_1.set_high();
    enable_2.set_high();
    enable_3.set_low();
    high_side_1.set_duty(0);
    high_side_2.set_duty(duty_2);
    high_side_3.set_duty(0);

    delay.delay_ms(comm_delay);

    // In line 2, out line 3
    enable_1.set_low();
    enable_2.set_high();
    enable_3.set_high();
    high_side_1.set_duty(0);
    high_side_2.set_duty(duty_2);
    high_side_3.set_duty(0);

    delay.delay_ms(comm_delay);

    // In line 1, out line 3
    enable_1.set_high();
    enable_2.set_low();
    enable_3.set_high();
    high_side_1.set_duty(duty_1);
    high_side_2.set_duty(0);
    high_side_3.set_duty(0);

    delay.delay_ms(comm_delay);
}
----

== Results

Using the code in `pwm/`, it is possible to drive the BLDC motor in open-loop mode at 3 ms per commutation step. For the 14N12P motor configuration, which has 7 electrical revolutions per mechanical revolution (so there are 42 commutations in one mechanical rotation), this implies 126 ms per mechanical rotation, or 476 RPM.

To run the code, plug in the DISCO board, install the toolchain as described in the `pwm/README.md`, and run:

[,bash]
----
cargo run
----

The experiment shows it is feasible to realise basic open-loop control a BLDC motor using generic PWM/timer modules in the STM32F746 series devices, and it is not necessary to use advanced motor control timers. Although the experiment is performed in open-loop mode at low speed, it is likely that regular timers along with analog to digital converters can be combined to realise sensorless feedback control for BLDC motors.

== Conclusions

There will not be a bottleneck due to PWM/timer modules when driving four BLDC motors. Six digital output channels (three PWM and three GPIO) are required per motor, so 24 pins in total. According to the xref:../../reference/appnote-brushless-dc-motor-control.pdf[Microchip application note], only a single ADC is required for motor, so four ADC channels are required in total.

It is highly likely that the STM32H7 series devices contain enough timers, ADCs, and processing speed, to handle the motor driving algorithms in the Cortex M4 core.
